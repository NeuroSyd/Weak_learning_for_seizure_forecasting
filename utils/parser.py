import os
import xml.etree.ElementTree as ET
from datetime import datetime
import pandas as pd
from io import StringIO


def sdy_extract(fn_study):
    study_name = fn_study.split('/')[-1]
    if study_name.split('.')[-1] == 'EEG':
        fn_sdy = '{}/{}'.format(fn_study, 'EEG.sdy')
    else:
        fn_sdy = '{}/{}'.format(fn_study, study_name.replace('eeg', 'sdy'))
    print(fn_sdy)
    tree_sdy = ET.parse(fn_sdy)
    root_sdy = tree_sdy.getroot()

    recording_start_time = ''
    recording_duration = ''
    eeg_sample_rate = ''
    creation_time = ''

    for child in root_sdy:
        if (child.tag == "Study"):
            creation_time = child.attrib['creation_time']
            try:
                recording_start_time = child.attrib['recording_start_time']
            except:
                recording_start_time = creation_time  # old recordings dont have recording_start_time

            try:
                recording_duration = child.attrib['recording_duration']
            except:
                recording_duration = child.attrib['study_length']
            eeg_sample_rate = child.attrib['eeg_sample_rate']
            try:
                fmt = '%Y-%m-%d %H:%M:%S'  # 2018-05-25 07:33:53
                creation_time_dt = datetime.strptime(creation_time, fmt)
                recording_start_time_dt = datetime.strptime(recording_start_time, fmt)
            except:
                fmt = '%d %b %Y %H:%M:%S'  # 2018-05-25 07:33:53
                creation_time_dt = datetime.strptime(creation_time, fmt)
                recording_start_time_dt = datetime.strptime(recording_start_time, fmt)
            gap_time = (recording_start_time_dt - creation_time_dt).total_seconds()
            return gap_time, creation_time_dt, recording_start_time_dt, recording_duration, eeg_sample_rate


def events_extract(fn_study):
    event_name = 'AN_{}'.format(fn_study.split('/')[-1])
    event_fn = '{}/{}.txt'.format(fn_study, event_name)
    print(event_fn)
    assert os.path.exists(event_fn) == True
    # The event file miss the first column so I will add it here, called Time
    ori_content = []
    with open(event_fn, 'r', encoding='utf-16-le') as f:
        for line in f:
            txt = line.strip()
            # txt = txt.replace('\x00','') # the text file generated by Profusion has some hidden bytes
            # ##### it turns out that Profusion was using utf-16-le encoding, but it works so no need to change for now :)
            if txt != '':
                ori_content.append(txt)

    ori_content[0] = 'Time\t{}'.format(ori_content[0])
    # print (ori_content)
    ori_content = '\n'.join(ori_content)

    events = pd.read_csv(StringIO(ori_content), sep='\t', header=0)
    print(events.head())
    print(events.columns)
    Recording_Time = events.columns[1]  # for some unknown reasons, can't use text as column name for Recording Time

    # perform sanity check to see if #sz onset==#sz end ########################
    events.dropna(inplace=True)
    sz_eeg_onset = events.loc[events['Tag'].str.contains('EEG SZ ONSET')]
    sz_eeg_end = events.loc[events['Tag'].str.contains('EEG SZ END')]
    sz_clin_onset = events.loc[events['Tag'].str.contains('CLINICAL SZ ONSET')]
    sz_clin_end = events.loc[events['Tag'].str.contains('CLINICAL SZ END')]
    print(len(sz_eeg_onset), len(sz_eeg_end))
    if len(sz_eeg_onset) > 0:
        assert len(sz_eeg_onset) == len(sz_eeg_end)
    # if len(sz_clin_onset) > 0:
    #     assert len(sz_clin_onset) == len(sz_clin_end)
    ############################################################################

    sz_table = pd.DataFrame(columns=["onset", "onset_datetime", "end", "end_datetime"])

    for index, row in events.iterrows():
        if 'EEG SZ ONSET' in row['Tag']:
            print(row['Time'], row['Tag'])
            onset = row['Time']
            onset_datetime = '{} {}'.format(row[Recording_Time], row['Real Time'])
        elif 'EEG SZ END' in row['Tag']:
            print(row['Time'], row['Tag'])
            end = row['Time']
            end_datetime = '{} {}'.format(row[Recording_Time], row['Real Time'])
            sz_table = sz_table.append({"onset": onset,
                                        "onset_datetime": onset_datetime,
                                        "end": end,
                                        "end_datetime": end_datetime}, ignore_index=True)
    print(sz_table.head())

    return sz_table


def seizure_table_extract(fn_study_name, file_txt):
    fn_study = fn_study_name.split('.')[0]
    print(fn_study)
    sz_table = pd.DataFrame(columns=["onset", "end"])
    with open(file_txt, 'r') as f:
        while True:
            # Get next line from file
            line = f.readline()

            # if line is empty
            # end of file is reached
            if not line:
                break
            fn, st, sp, cl, _ = line.strip().split(' ')
            #print(fn, st, sp, cl, _)
            if fn == fn_study:

                if cl == 'seiz':
                    sz_table = sz_table.append({"onset": st,
                                                "end": sp},
                                                ignore_index=True)

    print(sz_table.shape)

    return sz_table


if __name__ == '__main__':

    fn_study = '/mnt/data8_NeuroSyd/datasets/RPA-EEG/2011/20110725{58A6DC48-6D74-4820-A992-430D9CE724C1}.eeg'
    events_extract(fn_study)

    fn_study_name = '20110725{58A6DC48-6D74-4820-A992-430D9CE724C1}.eeg'
    file_txt = '/home/yikai2/prediction_detection/detection_ref/ref_2011/2011_pat8.txt'
    seizure_table_extract(fn_study_name, file_txt)
